# ğŸ“ çœŸå®æ¥ç”µåœºæ™¯åº”ç”¨å®ç°æ–¹æ¡ˆ

## ğŸ¯ ç°çŠ¶åˆ†æ

æ‚¨è¯´å¾—éå¸¸å‡†ç¡®ï¼ç›®å‰çš„ç”µè¯æ™ºèƒ½ä»£æ¥åŠŸèƒ½ç¡®å®åªæ˜¯**æ¨¡æ‹Ÿæ¥ç”µæ¼”ç¤º**ï¼Œè¿˜æ²¡æœ‰æ¥å…¥çœŸå®çš„Androidç”µè¯ç³»ç»Ÿã€‚è®©æˆ‘ä¸ºæ‚¨åˆ†æçœŸå®æ¥ç”µåœºæ™¯çš„å®Œæ•´å®ç°æ–¹æ¡ˆã€‚

## ğŸ“Š æŠ€æœ¯å¯è¡Œæ€§åˆ†æ

### âœ… ç°æœ‰æŠ€æœ¯åŸºç¡€
é€šè¿‡åˆ†æç°æœ‰ä»£ç ï¼Œæˆ‘ä»¬å·²ç»å…·å¤‡äº†ï¼š
- **å®Œæ•´çš„ADBè¿æ¥æ¡†æ¶**ï¼š`app_automation_tools.py`ä¸­çš„ADBæ“ä½œ
- **Androidè®¾å¤‡æ§åˆ¶èƒ½åŠ›**ï¼šå±å¹•æˆªå›¾ã€UIæŸ¥æ‰¾ã€ç‚¹å‡»æ“ä½œ
- **APPè‡ªåŠ¨åŒ–ç»éªŒ**ï¼šæˆåŠŸçš„ä¸­å›½è”é€šAPPè‡ªåŠ¨åŒ–
- **æ™ºèƒ½åœºæ™¯ç®¡ç†**ï¼šå®Œæ•´çš„åœºæ™¯æ¨¡å¼å’Œè¯­éŸ³å›å¤ç³»ç»Ÿ

### âš ï¸ éœ€è¦è§£å†³çš„æ ¸å¿ƒæŒ‘æˆ˜
1. **ç”µè¯çŠ¶æ€ç›‘å¬**ï¼šå®æ—¶æ£€æµ‹æ¥ç”µ
2. **è‡ªåŠ¨æ¥å¬æ§åˆ¶**ï¼šç¨‹åºåŒ–æ¥å¬/æŒ‚æ–­ç”µè¯
3. **è¯­éŸ³è¾“å‡º**ï¼šæ’­æ”¾å›å¤è¯­éŸ³åˆ°é€šè¯ä¸­
4. **æƒé™è·å–**ï¼šAndroidç³»ç»Ÿçº§æƒé™
5. **å…¼å®¹æ€§**ï¼šä¸åŒAndroidç‰ˆæœ¬å’Œè®¾å¤‡

## ğŸ”§ å®ç°æ–¹æ¡ˆå¯¹æ¯”

### æ–¹æ¡ˆä¸€ï¼šADB + æ— éšœç¢æœåŠ¡ (æ¨èâ­â­â­â­â­)
```
ä¼˜ç‚¹ï¼š
âœ… åŸºäºç°æœ‰ADBæ¡†æ¶
âœ… æ— éœ€Rootæƒé™
âœ… å…¼å®¹æ€§å¥½
âœ… ç›¸å¯¹å®‰å…¨

å®ç°éš¾åº¦ï¼šä¸­ç­‰
æƒé™è¦æ±‚ï¼šæ— éšœç¢æœåŠ¡æƒé™
é€‚ç”¨åœºæ™¯ï¼šç”Ÿäº§ç¯å¢ƒ
```

### æ–¹æ¡ˆäºŒï¼šAndroidåŸç”ŸAPP
```
ä¼˜ç‚¹ï¼š
âœ… åŠŸèƒ½æœ€å®Œæ•´
âœ… ç”¨æˆ·ä½“éªŒæœ€ä½³
âœ… å¯å‘å¸ƒåˆ°åº”ç”¨å¸‚åœº

å®ç°éš¾åº¦ï¼šé«˜
æƒé™è¦æ±‚ï¼šç”µè¯ç®¡ç†æƒé™
é€‚ç”¨åœºæ™¯ï¼šç‹¬ç«‹åº”ç”¨
```

### æ–¹æ¡ˆä¸‰ï¼šRoot + ç³»ç»Ÿçº§æ§åˆ¶
```
ä¼˜ç‚¹ï¼š
âœ… åŠŸèƒ½æœ€å¼ºå¤§
âœ… æ§åˆ¶æœ€ç²¾ç¡®

ç¼ºç‚¹ï¼š
âŒ éœ€è¦Rootæƒé™
âŒ å®‰å…¨é£é™©é«˜
âŒ å…¼å®¹æ€§å·®
```

## ğŸš€ æ¨èå®ç°è·¯å¾„ï¼šADB + æ— éšœç¢æœåŠ¡

åŸºäºç°æœ‰æŠ€æœ¯æ ˆï¼Œæˆ‘æ¨èé‡‡ç”¨**æ–¹æ¡ˆä¸€**ï¼Œå…·ä½“å®ç°æ­¥éª¤å¦‚ä¸‹ï¼š

### é˜¶æ®µä¸€ï¼šç”µè¯çŠ¶æ€ç›‘å¬ (1-2å¤©)

#### 1.1 é€šè¿‡ADBç›‘å¬ç”µè¯çŠ¶æ€
```bash
# ç›‘å¬ç”µè¯çŠ¶æ€å˜åŒ–
adb shell dumpsys telephony.registry

# ç›‘å¬æ¥ç”µäº‹ä»¶
adb shell am monitor --gdb

# è·å–æ¥ç”µå·ç 
adb shell dumpsys activity | grep "mInCallActivity"
```

#### 1.2 å®ç°æ¥ç”µæ£€æµ‹
```python
def monitor_phone_state(self):
    """ç›‘å¬ç”µè¯çŠ¶æ€å˜åŒ–"""
    while self.monitoring:
        try:
            result = subprocess.run([
                self.adb_path, "shell", 
                "dumpsys", "telephony.registry"
            ], capture_output=True, text=True, timeout=5)
            
            if "mCallState=2" in result.stdout:  # CALL_STATE_RINGING
                phone_number = self._extract_phone_number(result.stdout)
                self._handle_incoming_call(phone_number)
                
        except Exception as e:
            self.logger.error(f"ç”µè¯ç›‘å¬å¼‚å¸¸: {e}")
        
        time.sleep(1)  # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
```

### é˜¶æ®µäºŒï¼šè‡ªåŠ¨æ¥å¬å®ç° (2-3å¤©)

#### 2.1 åŸºäºUIè‡ªåŠ¨åŒ–çš„æ¥å¬
```python
def auto_answer_call(self):
    """è‡ªåŠ¨æ¥å¬æ¥ç”µ"""
    try:
        # æˆªå–å±å¹•
        screenshot_path = self.take_screenshot()
        
        # æŸ¥æ‰¾æ¥å¬æŒ‰é’®
        answer_button = self._find_answer_button(screenshot_path)
        
        if answer_button:
            # ç‚¹å‡»æ¥å¬
            self.tap_element(answer_button['x'], answer_button['y'])
            
            # ç­‰å¾…æ¥é€š
            time.sleep(2)
            
            # æ’­æ”¾è¯­éŸ³å›å¤
            self._play_voice_response()
            
            # å»¶è¿ŸåæŒ‚æ–­
            time.sleep(10)
            self._end_call()
            
    except Exception as e:
        self.logger.error(f"è‡ªåŠ¨æ¥å¬å¤±è´¥: {e}")
```

#### 2.2 æ¥å¬æŒ‰é’®è¯†åˆ«ç®—æ³•
```python
def _find_answer_button(self, screenshot_path):
    """æ™ºèƒ½è¯†åˆ«æ¥å¬æŒ‰é’®"""
    # ä½¿ç”¨OCR + å›¾åƒè¯†åˆ«
    possible_buttons = [
        {"text": "æ¥å¬", "color": "green"},
        {"text": "æ¥å—", "color": "green"}, 
        {"icon": "phone_answer", "position": "bottom_center"},
        {"shape": "circle", "color": "green", "size": "large"}
    ]
    
    # ç»“åˆå¤šç§æ–¹å¼è¯†åˆ«
    return self._identify_ui_element(screenshot_path, possible_buttons)
```

### é˜¶æ®µä¸‰ï¼šè¯­éŸ³å›å¤ç³»ç»Ÿ (2-3å¤©)

#### 3.1 éŸ³é¢‘è¾“å‡ºå®ç°
```python
def _play_voice_response(self):
    """æ’­æ”¾è¯­éŸ³å›å¤åˆ°é€šè¯ä¸­"""
    scenario_response = self.scenarios[self.current_scenario]
    voice_file = f"voice_{self.current_scenario.value}.wav"
    
    # æ–¹æ³•1ï¼šé€šè¿‡åª’ä½“éŸ³é‡æ’­æ”¾
    self._play_audio_via_media_volume(voice_file)
    
    # æ–¹æ³•2ï¼šé€šè¿‡éº¦å…‹é£è¾“å…¥(éœ€è¦è™šæ‹ŸéŸ³é¢‘è®¾å¤‡)
    # self._play_audio_via_microphone(voice_file)
```

#### 3.2 TTSè¯­éŸ³ç”Ÿæˆ
```python
def generate_voice_responses(self):
    """ä¸ºæ‰€æœ‰åœºæ™¯ç”Ÿæˆè¯­éŸ³æ–‡ä»¶"""
    for scenario, config in self.scenarios.items():
        voice_file = f"data/voice_responses/voice_{scenario.value}.wav"
        
        # ä½¿ç”¨TTSç”Ÿæˆè¯­éŸ³
        self._text_to_speech(config.response_text, voice_file)
```

### é˜¶æ®µå››ï¼šæƒé™å’Œå…¼å®¹æ€§å¤„ç† (1-2å¤©)

#### 4.1 æ— éšœç¢æœåŠ¡æƒé™
```python
def request_accessibility_permission(self):
    """å¼•å¯¼ç”¨æˆ·å¼€å¯æ— éšœç¢æœåŠ¡"""
    try:
        # æ‰“å¼€æ— éšœç¢è®¾ç½®é¡µé¢
        subprocess.run([
            self.adb_path, "shell", "am", "start",
            "-a", "android.settings.ACCESSIBILITY_SETTINGS"
        ])
        
        return {
            "success": True,
            "message": "è¯·åœ¨è®¾ç½®ä¸­å¼€å¯æœ¬åº”ç”¨çš„æ— éšœç¢æœåŠ¡æƒé™"
        }
    except Exception as e:
        return {"success": False, "message": f"æƒé™è®¾ç½®å¤±è´¥: {e}"}
```

#### 4.2 è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥
```python
def check_device_compatibility(self):
    """æ£€æŸ¥è®¾å¤‡å…¼å®¹æ€§"""
    try:
        # è·å–Androidç‰ˆæœ¬
        version_result = subprocess.run([
            self.adb_path, "shell", "getprop", "ro.build.version.release"
        ], capture_output=True, text=True)
        
        android_version = float(version_result.stdout.strip())
        
        if android_version < 6.0:
            return {"compatible": False, "reason": "Androidç‰ˆæœ¬è¿‡ä½"}
        
        # æ£€æŸ¥å¿…è¦æƒé™
        permissions_check = self._check_required_permissions()
        
        return {
            "compatible": True,
            "android_version": android_version,
            "permissions": permissions_check
        }
        
    except Exception as e:
        return {"compatible": False, "reason": f"æ£€æŸ¥å¤±è´¥: {e}"}
```

## ğŸ“± å®Œæ•´å®ç°ä»£ç æ¡†æ¶

### æ ¸å¿ƒç±»è®¾è®¡
```python
class RealPhoneAutoAnswer(PhoneAutoAnswerManager):
    """çœŸå®ç”µè¯è‡ªåŠ¨ä»£æ¥ç®¡ç†å™¨"""
    
    def __init__(self):
        super().__init__()
        self.monitoring = False
        self.monitor_thread = None
        
    def start_phone_monitoring(self):
        """å¯åŠ¨ç”µè¯ç›‘å¬"""
        if not self.check_device_connection():
            return {"success": False, "message": "è®¾å¤‡æœªè¿æ¥"}
            
        if not self._check_permissions():
            return {"success": False, "message": "æƒé™ä¸è¶³"}
        
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_phone_state)
        self.monitor_thread.start()
        
        return {"success": True, "message": "ç”µè¯ç›‘å¬å·²å¯åŠ¨"}
    
    def _monitor_phone_state(self):
        """ç›‘å¬ç”µè¯çŠ¶æ€ï¼ˆåå°çº¿ç¨‹ï¼‰"""
        while self.monitoring:
            try:
                if self._detect_incoming_call():
                    call_info = self._get_call_info()
                    self._handle_real_incoming_call(call_info)
            except Exception as e:
                self.logger.error(f"ç›‘å¬å¼‚å¸¸: {e}")
            time.sleep(0.5)
    
    def _handle_real_incoming_call(self, call_info):
        """å¤„ç†çœŸå®æ¥ç”µ"""
        if not self.enabled:
            return
            
        try:
            # è®°å½•æ¥ç”µ
            self._log_incoming_call(call_info)
            
            # å»¶è¿Ÿæ¥å¬(é¿å…å¤ªå¿«)
            time.sleep(2)
            
            # è‡ªåŠ¨æ¥å¬
            if self._auto_answer_call():
                # æ’­æ”¾è¯­éŸ³å›å¤
                self._play_scenario_response()
                
                # å»¶è¿ŸæŒ‚æ–­
                time.sleep(self._get_response_duration())
                self._end_call()
                
            # è®°å½•é€šè¯å®Œæˆ
            self._log_call_completed(call_info)
            
        except Exception as e:
            self.logger.error(f"å¤„ç†æ¥ç”µå¤±è´¥: {e}")
```

### å·¥å…·æ–¹æ³•æ‰©å±•
```python
@tool("start_real_phone_monitoring", 
      description="å¯åŠ¨çœŸå®ç”µè¯ç›‘å¬å’Œè‡ªåŠ¨ä»£æ¥", 
      group="phone_real")
def start_real_phone_monitoring() -> Dict[str, Any]:
    """å¯åŠ¨çœŸå®ç”µè¯ç›‘å¬"""
    real_phone_manager = RealPhoneAutoAnswer()
    return real_phone_manager.start_phone_monitoring()

@tool("check_phone_permissions",
      description="æ£€æŸ¥ç”µè¯è‡ªåŠ¨ä»£æ¥æ‰€éœ€æƒé™",
      group="phone_real")  
def check_phone_permissions() -> Dict[str, Any]:
    """æ£€æŸ¥æƒé™çŠ¶æ€"""
    real_phone_manager = RealPhoneAutoAnswer()
    return real_phone_manager.check_device_compatibility()
```

## ğŸ”’ æƒé™å’Œå®‰å…¨è€ƒè™‘

### å¿…éœ€æƒé™
```xml
<!-- Androidåº”ç”¨éœ€è¦çš„æƒé™ -->
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-permission android:name="android.permission.CALL_PHONE" />
<uses-permission android:name="android.permission.ANSWER_PHONE_CALLS" />
<uses-permission android:name="android.permission.RECORD_AUDIO" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

### ç”¨æˆ·æˆæƒæµç¨‹
```python
def setup_permissions_guide(self):
    """æƒé™è®¾ç½®æŒ‡å¯¼"""
    steps = [
        "1. å¼€å¯æ— éšœç¢æœåŠ¡æƒé™",
        "2. æˆäºˆç”µè¯ç®¡ç†æƒé™", 
        "3. å…è®¸åº”ç”¨è‡ªåŠ¨æ¥å¬æ¥ç”µ",
        "4. å¼€å¯å½•éŸ³æƒé™(ç”¨äºè¯­éŸ³æ’­æ”¾)",
        "5. è®¾ç½®ä¸ºé»˜è®¤æ‹¨å·åº”ç”¨(å¯é€‰)"
    ]
    
    return {
        "setup_required": True,
        "steps": steps,
        "estimated_time": "5-10åˆ†é’Ÿ"
    }
```

## âš¡ å¿«é€ŸåŸå‹å®ç°

è®©æˆ‘ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ª**å¿«é€ŸéªŒè¯ç‰ˆæœ¬**ï¼Œå¯ä»¥ç«‹å³æµ‹è¯•çœŸå®æ¥ç”µæ£€æµ‹ï¼š

### 1. æ¥ç”µæ£€æµ‹éªŒè¯
```python
def quick_test_call_detection():
    """å¿«é€Ÿæµ‹è¯•æ¥ç”µæ£€æµ‹"""
    adb_path = "./platform-tools/adb.exe"
    
    print("ğŸ“ å¼€å§‹ç›‘å¬æ¥ç”µçŠ¶æ€...")
    print("è¯·ç”¨å¦ä¸€éƒ¨æ‰‹æœºæ‹¨æ‰“æµ‹è¯•è®¾å¤‡...")
    
    while True:
        try:
            result = subprocess.run([
                adb_path, "shell", "dumpsys", "telephony.registry"
            ], capture_output=True, text=True, timeout=3)
            
            # æ£€æŸ¥æ¥ç”µçŠ¶æ€
            if "mCallState=1" in result.stdout:  # RINGING
                print("ğŸ”” æ£€æµ‹åˆ°æ¥ç”µï¼")
                # å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è‡ªåŠ¨æ¥å¬é€»è¾‘
                
        except Exception as e:
            print(f"æ£€æµ‹å¼‚å¸¸: {e}")
            
        time.sleep(1)
```

### 2. UIè‡ªåŠ¨åŒ–æ¥å¬æµ‹è¯•
```python
def test_auto_answer_ui():
    """æµ‹è¯•UIè‡ªåŠ¨åŒ–æ¥å¬"""
    tools = AppAutomationTools()
    
    # æˆªå–å½“å‰å±å¹•
    screenshot = tools.take_screenshot()
    
    # æŸ¥æ‰¾ç»¿è‰²åœ†å½¢æŒ‰é’®(é€šå¸¸æ˜¯æ¥å¬æŒ‰é’®)
    answer_button = tools._find_green_circle_button(screenshot)
    
    if answer_button:
        print("âœ… æ‰¾åˆ°æ¥å¬æŒ‰é’®ï¼Œä½ç½®:", answer_button)
        # tools.tap_element(answer_button['x'], answer_button['y'])
    else:
        print("âŒ æœªæ‰¾åˆ°æ¥å¬æŒ‰é’®")
```

## ğŸ¯ å®æ–½å»ºè®®

### ç«‹å³å¯è¡Œçš„æ­¥éª¤ï¼š
1. **ğŸ”§ å…ˆå®ç°æ¥ç”µæ£€æµ‹**ï¼šéªŒè¯èƒ½å¦å‡†ç¡®æ£€æµ‹åˆ°æ¥ç”µ
2. **ğŸ“± æµ‹è¯•UIè¯†åˆ«**ï¼šç¡®è®¤èƒ½å¦æ‰¾åˆ°æ¥å¬æŒ‰é’®
3. **ğŸ¤ éªŒè¯éŸ³é¢‘è¾“å‡º**ï¼šæµ‹è¯•è¯­éŸ³æ’­æ”¾åˆ°é€šè¯çš„å¯è¡Œæ€§

### åˆ†é˜¶æ®µæ¨è¿›ï¼š
- **Week 1**: æ¥ç”µæ£€æµ‹ + UIè¯†åˆ«
- **Week 2**: è‡ªåŠ¨æ¥å¬ + è¯­éŸ³æ’­æ”¾  
- **Week 3**: æƒé™å¤„ç† + å…¼å®¹æ€§æµ‹è¯•
- **Week 4**: é›†æˆæµ‹è¯• + ä¼˜åŒ–å®Œå–„

## ğŸš¨ é‡è¦æé†’

### æ³•å¾‹åˆè§„
- ç¡®ä¿ç¬¦åˆå½“åœ°æ³•å¾‹æ³•è§„
- è·å¾—ç”¨æˆ·æ˜ç¡®æˆæƒ
- ä¸å¾—ç”¨äºæ¶æ„ç›®çš„

### æŠ€æœ¯é£é™©
- ä¸åŒè®¾å¤‡å·®å¼‚è¾ƒå¤§
- Androidç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜
- å¯èƒ½å½±å“æ­£å¸¸é€šè¯åŠŸèƒ½

### ç”¨æˆ·ä½“éªŒ
- æä¾›ç®€å•çš„å¼€å…³æ§åˆ¶
- æ¸…æ™°çš„çŠ¶æ€åé¦ˆ
- å®Œå–„çš„å¼‚å¸¸å¤„ç†

---

## ğŸ’¡ ç»“è®º

çœŸå®æ¥ç”µåœºæ™¯å®Œå…¨å¯ä»¥å®ç°ï¼åŸºäºç°æœ‰çš„å¼ºå¤§Androidè‡ªåŠ¨åŒ–åŸºç¡€ï¼Œé€šè¿‡**ADB + æ— éšœç¢æœåŠ¡**çš„æ–¹æ¡ˆï¼Œæˆ‘ä»¬å¯ä»¥åœ¨**2-3å‘¨å†…**å®ç°å®Œæ•´çš„çœŸå®ç”µè¯è‡ªåŠ¨ä»£æ¥åŠŸèƒ½ã€‚

å…³é”®æ˜¯è¦åˆ†é˜¶æ®µéªŒè¯æ¯ä¸ªæŠ€æœ¯ç¯èŠ‚ï¼Œç¡®ä¿åœ¨æ‚¨çš„å…·ä½“è®¾å¤‡å’ŒAndroidç‰ˆæœ¬ä¸Šèƒ½å¤Ÿç¨³å®šå·¥ä½œã€‚

**æ‚¨å¸Œæœ›æˆ‘ä»¬ä»å“ªä¸ªé˜¶æ®µå¼€å§‹å®ç°ï¼Ÿ**
